---
title: Technical Guide to Gatsby's SEO
description: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam eu iaculis elit.
date: 2020-11-12
modifiedDate: 2020-11-14
published: true
cover: ./cover.jpg
coverAlt: SEO image
---

import { Message } from "theme-ui"

If you are here it means that you care about organic SEO and want more people to
discover your content. This makes total sense, otherwise why even bother
creating content? In this blog post we are going to discuss what we as engineers
can do better in order to make web crawler's life a little easier and hopefully
get rewarded for it. Gatsby and `react-helmet` are going to be our main weapons.

## Prerequisites

I'm making several assumptions in this article:

1. You already have a basic understanding of how Gatsby Node API and GraphQL
   works.
2. The project I'm going to show will have a certain project structure,
   which we will go over shortly. Though don't worry too much about this part,
   because it should be pretty easy to adopt the same principals for a project with
   a different project structure.
3. All blog post examples are written using MDX and Theme-UI, so if you are using
   markdown or different styling solution some things might look slightly different
   for you.

And finally if you have any questions feel free to look at the
[final version](https://github.com/iamskok/gatsby-seo)) of the project
or [tweet](https://twitter.com/iamskok) at me with your question.

## Project Structure

The blog we are going to work on has 4 pages - Home, Blog, Contact, About, and an
Article template. I prefer to keep the actual content outside of `./src` directory
in order to have a clear separation between source code and the actual content. The
content folder can be named as `posts`, `articles`, or `garden` (AKA
[digital garden](https://joelhooks.com/digital-garden)). I'm gonna roll with `posts`.
Every post will be living in it's own folder with an `index.mdx`. All images which will
be used in the post will also be placed in the same `posts` directory. Generic
images are stored in `./src/images`. And that's about it for the project structure,
everything else is pretty standard.

```
├── gatsby-config.js
├── gatsby-node.js
├── site-metadata.js
├── posts
│   ├── article-1
│   │   ├── cover.jpg
│   │   └── index.mdx
│   ├── article-2
│   │   ├── cover.jpg
│   │   └── index.mdx
│   └── article-3
│       ├── cover.jpg
│       └── index.mdx
├── src
│   ├── components
│   ├── images
│   ├── pages
│   │   ├── about.js
│   │   ├── blog.js
│   │   ├── contact.js
│   │   └── index.js
│   └── templates
│       └── article.js
└── static
```

## Site Metadata and `useSiteMetadata` Hook

Before jumping right into the actual coding we have to define define
the data we are going to pass to the SEO components as well as some
mechanism for retrieving the data.

In order to keep `gatsby-config.js` file slim let's create a separate file
which is gonna hold all the static metadata about our blog -
`touch site-metadata.js`.

```js
module.exports = {
  firstName: `Jane`,
  lastName: `Doe`,
  siteUrl: `https://gatsby-seo.netlify.app`,
  logo: {
    url: `logo.jpg`,
    width: 640,
    height: 640,
  },
  language: `en_US`,
  socialMedia: {
    twitter: `https://twitter.com/gatsbyjs`,
    github: `https://github.com/gatsbyjs`,
  },
  address: {
    addressCountry: `US`,
    addressLocality: `Los Angeles`,
    addressRegion: `GA`,
  },
  speakableSelector: [`[data-speakable="true"]`],
  pages: {
    home: {
      to: `/`,
      breadcrumb: `Home`,
      title: `Jane Doe`,
      description: `Jane Doe's personal blog`,
      coverAlt: `Two corgis sitting next to each other`,
      type: `WebPage`,
    },
    blog: {
      to: `/blog/`,
      breadcrumb: `Blog`,
      title: `Blog`,
      description: `Thoughts on software engineering`,
      coverAlt: `Brown retriever is licking it's nose`,
      type: `Blog`,
    },
    contact: {
      to: `/contact/`,
      breadcrumb: `Contact`,
      title: `Contact Jane Doe`,
      description: `Jane Doe's contact information`,
      coverAlt: `Bulldog is chilling on the groud`,
      type: `ContactPage`,
    },
    about: {
      to: `/about/`,
      breadcrumb: `About`,
      title: `About Jane Doe`,
      description: `Jane Doe's biography`,
      coverAlt: `French bulldog is hanging out on the playgroud`,
      type: `AboutPage`,
    },
    article: {
      type: `Article`,
    },
  },
}
```

- `speakableSelector` this is a selector which will tell search engines and some other assistive
  technologies that a particular section on the page is "speakable".
- `to` is a URL pathname.
- `breadcrumb` is a breadcrumb title
- `coverAlt` is the same as image `alt` attribute, but for your cover images.
- `lang` the language of your content. Consists of [language code](https://www.w3schools.com/tags/ref_language_codes.asp)
  and an options [country code](https://www.w3schools.com/tags/ref_country_codes.asp)

Everything else should be pretty self-explanatory. Replace all the values
with your own information, but keep page's `type` as is.

Our next step is to import this file in `gatsby-config.js` so all this information will
become accessible to the GraphQL layer.

```js
const siteMetadata = require("./site-metadata")

module.exports = {
  siteMetadata,
  // ...
}
```

Once we placed the data in the right place we need some way to retrieve it from
react components using GraphQL queries. `useStaticQuery` is exactly what we are
looking. Create `hooks` directory in `./src` - `touch src/hooks/useSiteMetadata.js`

```js
import { useStaticQuery, graphql } from "gatsby"

export default () => {
  const {
    site: { siteMetadata },
  } = useStaticQuery(
    graphql`
      query {
        site {
          siteMetadata {
            firstName
            lastName
            siteUrl
            logo {
              url
              width
              height
            }
            language
            socialMedia {
              twitter
              github
            }
            address {
              addressCountry
              addressLocality
              addressRegion
            }
            speakableSelector
            pages {
              home {
                to
                breadcrumb
                title
                description
                coverAlt
                type
              }
              blog {
                to
                breadcrumb
                title
                description
                coverAlt
                type
              }
              contact {
                to
                breadcrumb
                title
                description
                coverAlt
                type
              }
              about {
                to
                breadcrumb
                title
                description
                coverAlt
                type
              }
              article {
                type
              }
            }
          }
        }
      }
    `
  )

  return siteMetadata
}
```

We are listing every property from `./site-metadata.js` in the graphql query,
destructuring `siteMetadata`, because we are not making any use out of it and now
we are ready to retrieve the data as:

```jsx
import useSiteMetadata from "../../hooks/useSiteMetadata"

const Welcome = () => {
  const { firstName } = useSiteMetadata()

  return <h1>Hello! My name is {firstName}</h1>
}
```

## Basic Data Flow

All the data brewing will start at the page and template level. We are going
to retrieve it using gatsby page queries and `useSiteMetadata` hook.
After this it's going to drain down in the `Layout` component. `Layout` component
will be a place where all the data is aggregated, sorted, and passed deeper
in the actual SEO components.

## Using `useSiteMetadata` Hook To Pull Page Data

Every page has a corresponding data in `./site-metadata.js`, so let's get it in
the page components. Here is the example for the Home page.

```jsx {9,21}
/** @jsx jsx */
import { jsx, Styled } from "theme-ui"
import useSiteMetadata from "../hooks/useSiteMetadata"
import Layout from "../components/Layout"

const Home = () => {
  const {
    pages: {
      home: { to, title, description, coverAlt, type, breadcrumb },
    },
  } = useSiteMetadata()

  return (
    <Layout
      to={to}
      title={title}
      description={description}
      coverAlt={coverAlt}
      breadcrumb={breadcrumb}
      type={type}
      pageName="home"
    >
      {/* ... */}
    </Layout>
  )
}

export default Home
```

There 2 important pieces here:

- page title in `useSitemetaData` destructuring
- `pageName` prop, which corresponds to the component name

They are going to change from page to page. Now add the same
code to the rest of the pages. Feel free to check out the example
[repo](https://github.com/iamskok/gatsby-seo-draft/tree/master/src/pages).

### GraphQL Fragment For Cover Images

Before moving to the Gatsby page queries let's do some preparation. As you
might already know Gatsby has an awesome plugin
[gatsby-transformer-sharp](https://www.gatsbyjs.com/plugins/gatsby-transformer-sharp),
which is used for creating multiple images of the right sizes and resolutions.
It's gonna help us a ton with generating cover images for various aspect ratios.
Why can't we use the same image you might wonder? Well, because all social networks
and search engines have different requirments.

- [Facebook](https://developers.facebook.com/docs/sharing/webmasters/images/)
  recommends images to be at least 1200x630 pixels.
- [Twitter](https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/summary-card-with-large-image)
  recommends aspect ratio of 2:1 with minimum dimensions of 300x157 pixels.
- [Google](https://developers.google.com/search/docs/data-types/article) says
  that their images has to be at least 696 pixels wide and suggests
  to provide multiple images with the following aspect ratios: 16x9, 4x3, and 1x1.

Now let's have a look at how this might look in practice for the Home cover image:

```graphql
query {
  file(relativePath: { eq: "home.jpg" }) {
    childImageSharp {
      facebook: fixed(width: 1600, height: 838) {
        src
      }
      twitter: fixed(width: 1600, height: 800) {
        src
      }
      google1x1: fixed(width: 1600, height: 1600) {
        src
      }
      google4x3: fixed(width: 1600, height: 1200) {
        src
      }
      google16x9: fixed(width: 1600, height: 900) {
        src
      }
    }
  }
}
```

Let's break it down. First we are querying for a File in GraphQL
using `gatsby-source-filesystem`. In our case we are targeting a
file by it's relative path, which equals (`eq` operator must match
the given data exactly) to `home.jpg`. It triggers copying of this
file to the `public` directory.

<Message variant="primary">
  Relative path is based on the line of code you put in the
  `gatsby-source-filesystem` in `gatsby-config.js`, in our case it's
  `/src/images`.
</Message>

In the snippet above we are using Gatsby aliases, because we need to
run multiple queries with different arguments on the same data
source - `childImageSharp`.

This query will be required for every page and this is not DRY, because
the only piece, which will be different is the image title. GraphQL
fragments will come to the resque. Fragments are reusable units, they
let you construct sets of fields, and then include them in queries where
you need to.

Let's create our fragment `touch src/fragments/ImageSharpFields.js`.

```js
import { graphql } from "gatsby"

export const ChildImageSharpFields = graphql`
  fragment ChildImageSharpFields on ImageSharp {
    google1x1: fixed(width: 1600, height: 1600) {
      src
    }
    google4x3: fixed(width: 1600, height: 1200) {
      src
    }
    google16x9: fixed(width: 1600, height: 900) {
      src
    }
    twitter: fixed(width: 1600, height: 800) {
      src
    }
    facebook: fixed(width: 1600, height: 838) {
      src
    }
  }
`
```

We are defining `FragmentName` that will be referenced in other
queries. Specifing `TypeName` of an object the fragment
will be used on - `ImageSharp`. Than we move aliases from the
initial example in the query body. And to make this fragment accessible
inside of the other GraphQL queries we using named export (There is no need
to import this fragment, Gatsby automatically makes it globally available).

Now you can use this fragment. This looks way better!

```graphql
query {
  file(relativePath: { eq: "home.jpg" }) {
    childImageSharp {
      ...ChildImageSharpFields
    }
  }
}
```

## Using Gatsby Page Query To Pull Page Data

At this point we have `useSiteMetadata` hook and fragments in place,
so we can finish pulling all the data we need.

```jsx {7,13,20,31-39}
/** @jsx jsx */
import { jsx, Styled } from "theme-ui"
import { graphql } from "gatsby"
import useSiteMetadata from "../hooks/useSiteMetadata"
import Layout from "../components/Layout"

const Home = ({ data }) => {
  const {
    pages: {
      home: { to, title, description, coverAlt, type, breadcrumb },
    },
  } = useSiteMetadata()
  const covers = data?.file?.childImageSharp

  return (
    <Layout
      to={to}
      title={title}
      description={description}
      covers={{ ...covers }}
      coverAlt={coverAlt}
      breadcrumb={breadcrumb}
      type={type}
      pageName="home"
    >
      {/* ... */}
    </Layout>
  )
}

export const query = graphql`
  query {
    file(relativePath: { eq: "home.jpg" }) {
      childImageSharp {
        ...ChildImageSharpFields
      }
    }
  }
`

export default Home
```

On line `31-39` we difine the query for the cover image and the data
coming from it becomes accessible via `data` prop in `Home` component.
Let's grab the part we are interested in - `covers` and spread it in
`covers` prop of `Layout` component.

Here is the example of the `Article` template.

```jsx
/** @jsx jsx */
import { jsx, Styled, Flex } from "theme-ui"
import { graphql } from "gatsby"
import { MDXRenderer } from "gatsby-plugin-mdx"
import Img from "gatsby-image"
import useSiteMetadata from "../hooks/useSiteMetadata"
import Layout from "../components/Layout"

const Article = ({ data, pageContext }) => {
  const {
    mdx: {
      body,
      frontmatter: { title, description, date, modifiedDate, cover, coverAlt },
    },
  } = data
  const { slug } = pageContext
  const {
    pages: {
      article: { type, breadcrumb },
    },
  } = useSiteMetadata()

  const childImageSharp = cover?.childImageSharp

  return (
    <Layout
      type={type}
      slug={slug}
      title={title}
      date={date}
      modifiedDate={modifiedDate}
      covers={{ ...childImageSharp }}
      coverAlt={coverAlt}
      description={description}
      breadcrumb={breadcrumb}
      pageName="article"
    >
      {/* ... */}
    </Layout>
  )
}

export default Article

export const query = graphql`
  query($id: String!) {
    mdx(id: { eq: $id }) {
      id
      body
      frontmatter {
        title
        description
        date(formatString: "MMMM DD, YYYY")
        modifiedDate(formatString: "MMMM DD, YYYY")
        coverAlt
        cover {
          childImageSharp {
            ...ChildImageSharpFields
          }
        }
      }
    }
  }
`
```

In `Article` template we are taking `slug` from `pageContext`, using
`useSiteMetadata` to query `type` and `breadcrumb` and the rest of the
data comes from the page query, specifically from `frontmatter` fields
on `mdx`.

If you are not familiar with `pageContext` have a look at the
[Gatsby Docs](https://www.gatsbyjs.com/docs/creating-and-modifying-pages/#pass-context-to-pages)
or check out the [`gatsby-config.js` from the example repo](https://github.com/iamskok/gatsby-seo-draft/blob/master/gatsby-node.js).

## `Layout` component

`Layout` is the most data heavy component. It receives multiple props from
the data passed to it from pages and templates and fetches the remaining
static data using `useSiteMetadata` hook. Let's create one
`touch src/components/Layout/index.js`.

```jsx {35-41,43-60}
/** @jsx jsx */
import { Fragment } from "react"
import { jsx } from "theme-ui"
import useSiteMetadata from "../../hooks/useSiteMetadata"
import Head from "../Head"
import SchemaOrg from "../SchemaOrg"

const Layout = ({
  children,
  to,
  slug,
  title,
  description,
  cover,
  covers,
  coverAlt,
  pageName,
  type,
  breadcrumb,
  date,
  modifiedDate,
}) => {
  const {
    siteUrl,
    firstName,
    lastName,
    socialMedia,
    pages,
    logo,
    language,
    address,
    speakableSelector,
  } = useSiteMetadata()

  const isPage = {
    article: pageName === `article`,
    home: pageName === `home`,
    blog: pageName === `blog`,
    about: pageName === `about`,
    contact: pageName === `contact`,
  }

  const page = {
    url: isPage.home
      ? siteUrl
      : isPage.article
      ? `${siteUrl}${slug}`
      : `${siteUrl}${to}`,
    speakableSelector: !isPage.blog && speakableSelector,
    covers: (() => {
      const coverURLs = {}
      for (const [key, { src }] of Object.entries(covers)) {
        coverURLs[key] = `${siteUrl}${src}`
      }
      return coverURLs
    })(),
  }

  return (
    <Fragment>
      <Head
        url={page.url}
        title={title}
        description={description}
        covers={page.covers}
        coverAlt={coverAlt}
        firstName={firstName}
        lastName={lastName}
        socialMedia={socialMedia}
        date={date}
        language={language}
        pages={pages}
        isPage={isPage}
      />
      {/* ... */}
      <SchemaOrg
        to={to}
        slug={slug}
        url={page.url}
        siteUrl={siteUrl}
        title={title}
        description={description}
        covers={page.covers}
        firstName={firstName}
        lastName={lastName}
        socialMedia={socialMedia}
        type={type}
        breadcrumb={breadcrumb}
        date={date}
        modifiedDate={modifiedDate}
        address={address}
        language={language}
        logo={logo}
        pages={pages}
        isPage={isPage}
        speakableSelector={page.speakableSelector}
      />
    </Fragment>
  )
}

export default Layout
```

On line `35-41` we create `isPage` object which acts as helpers in the
data filtering process. This object is going to be passed as prop down in
`Head` and `SchemaOrg` components.

Line `43-60` defines `page` object which composes the proper data, which is
going to be passed down the tree. `url` property constructs page url for a
current page.

- Home - `/`
- Blog - `/blog/`
- Contact - `/contact/`
- About - `/about/`
- Article - `/blog/article-title/`

`speakableSelector` is used on all of the templates except blog and this is what
we check with `!isPage.blog`.

`covers` takes care of transforming cover images object. GraphQL returns `covers`
object which looks, like:

```json
{
  "google1x1": {
    "src": "/static/402ec135e08c3b799c16c08a82ae2dd8/acd4e/home.jpg"
  },
  "google4x3": {
    "src": "/static/402ec135e08c3b799c16c08a82ae2dd8/feead/home.jpg"
  },
  "google16x9": {
    "src": "/static/402ec135e08c3b799c16c08a82ae2dd8/fb8ef/home.jpg"
  },
  "twitter": {
    "src": "/static/402ec135e08c3b799c16c08a82ae2dd8/70d01/home.jpg"
  },
  "facebook": {
    "src": "/static/402ec135e08c3b799c16c08a82ae2dd8/10355/home.jpg"
  }
}
```

`covers` is being used in multiple places, so it's going to be much nicer
if the object will be take in this format:

```
{
  "google1x1": "/static/402ec135e08c3b799c16c08a82ae2dd8/acd4e/home.jpg",
  "google4x3": "/static/402ec135e08c3b799c16c08a82ae2dd8/feead/home.jpg",
  "google16x9": "/static/402ec135e08c3b799c16c08a82ae2dd8/fb8ef/home.jpg",
  "twitter": "/static/402ec135e08c3b799c16c08a82ae2dd8/70d01/home.jpg",
  "facebook": "/static/402ec135e08c3b799c16c08a82ae2dd8/10355/home.jpg",
}
```

## Head Component

`Head` component will consist of several other components. I personally
prefer breaking everything into smaller pieces, but I can also see that
someone might prefer one bigger component. Your call!

```jsx
import React from "react"
import Html from "./Html"
import Title from "./Title"
import Description from "./Description"
import OpenGraph from "./OpenGraph"
import Twitter from "./Twitter"

const Head = ({
  url,
  title,
  description,
  covers: { twitter: twitterCover, facebook: facebookCover },
  coverAlt,
  socialMedia,
  date,
  language,
  firstName,
  lastName,
  pages: {
    home: { title: siteName },
  },
  isPage,
}) => {
  const { twitter: twitterHandle } = socialMedia

  return (
    <>
      <Html language={language} />
      <Title title={title} />
      <Description description={description} />
      <OpenGraph
        url={url}
        title={title}
        description={description}
        image={facebookCover}
        imageAlt={coverAlt}
        publishedTime={date}
        siteName={siteName}
        firstName={firstName}
        lastName={lastName}
        locale={language}
        seeAlso={socialMedia}
        isArticle={isPage.article}
      />
      <Twitter
        title={title}
        description={description}
        image={twitterCover}
        imageAlt={coverAlt}
        creator={twitterHandle}
      />
    </>
  )
}

export default Head
```

Nothing fancy is going on here we are just receiving data from `Layout`
component and passing it further down.

### HTML Component

In HTML, the language declaration is an attribute that states the language
of the page’s content and optionally it's geographic location.

```jsx
import React from "react"
import { Helmet } from "react-helmet"

const Html = ({ language }) => (
  <Helmet>
    <html lang={language} />
  </Helmet>
)

export default Html
```

We are wrapping `html` tag in `Helmet` component, which will output
it in the document head.

> This reusable React component will manage all of your changes to the
> document head. Helmet takes plain HTML tags and outputs plain HTML tags.
> It's dead simple, and React beginner friendly.
>
> [`react-helmet` GitHub page](https://github.com/nfl/react-helmet)

### Title Component

Almost identical thing happens in `Title` component, but this
time we are wrapping `title` tag in `Helmet`.

```jsx
import React from "react"
import { Helmet } from "react-helmet"

const Title = ({ title }) => {
  return (
    <Helmet>
      <title>{title}</title>
    </Helmet>
  )
}

export default Title
```

### Description Component

```jsx
import React from "react"
import { Helmet } from "react-helmet"

const Description = ({ description }) => (
  <Helmet>
    <meta name="description" content={description} />
  </Helmet>
)

export default Description
```

### OpenGraph Component

The Open Graph protocol is supported by a wide range of social platforms which
includes Facebook (it also created this protocol in 2010), LinkedIn, Pinterest,
Twitter, and others. To learn more about it you can have a look at
[Open Graph protocol documention](https://ogp.me/)

Open Graph component is going to render data conditionally based on the page type.
This is when `isPage` object, which is being passed down from `Layout` component
becomes really handy.

```jsx
import React from "react"
import { Helmet } from "react-helmet"

const OpenGraph = ({
  url,
  title,
  description,
  image,
  imageAlt,
  publishedTime,
  siteName,
  firstName,
  lastName,
  locale,
  seeAlso,
  isArticle,
}) => (
  <Helmet>
    <meta property="og:url" content={url} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content={image} />
    <meta property="og:image:alt" content={imageAlt} />
    <meta property="og:site_name" content={siteName} />
    <meta property="og:locale" content={locale} />
    {!isArticle && <meta property="profile:first_name" content={firstName} />}
    {!isArticle && <meta property="profile:last_name" content={lastName} />}
    <meta property="og:type" content={isArticle ? `article` : `website`} />
    {isArticle && (
      <meta property="article:published_time" content={publishedTime} />
    )}
    {isArticle && (
      <meta property="article:author" content={`${firstName} ${lastName}`} />
    )}
  </Helmet>
)

export default OpenGraph
```

- `og:type` the type of your object, which is represented in Open Graph. It can be
  one of music, video, website, profile, article, and serveral others. In our blog
  we will be using `article` if it's an article template or `website` for the rest of
  the pages. (Required field).
- `og:title` blog post or a page title. (Required field).
- `og:description` a one to two sentence description of the page content.
- `og:url` the canonical URL of the object. Make sure to pay close attention to
  `www` subdomain and trailing `/`. (Required field).
- `og:image` cover image. (Required field).
- `og:image:alt` cover image description. (Techically not required, but I urge you to use it).
- `og:site_name` your blog name.
- `og:locale` the language of the content. It default to `en_US`.
  in [Pinterest documentation](https://developers.pinterest.com/docs/rich-pins/reference/).
- `article:author` author of the article if `og:type` is `article`.
- `article:published_time` publish time of the article if `og:type` is `article`.
- `profile:first_name` your first name if `og:type` is `website`.
- `profile:last_name` your last name if `og:type` is `website`.

To debug Open Graph markup you can use
[Facebook Debug Tool](https://developers.facebook.com/tools/debug), but unfortunatelly
it requires to Facebook developer's account.

### Twitter Component

Twitter markup has some intersections with Open Graph.
In certain cases when Twitter can't find twitter meta tags it will
fallback into using Open Graph meta tags. You can read more about it
in [Twitter docs](https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/markup)

```jsx
import React from "react"
import { Helmet } from "react-helmet"

const Twitter = ({ title, description, image, imageAlt, creator }) => (
  <Helmet>
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:title" content={title} />
    <meta property="twitter:description" content={description} />
    <meta property="twitter:image" content={image} />
    <meta property="twitter:image:alt" content={imageAlt} />
    <meta name="twitter:creator" content={creator} />
  </Helmet>
)

export default Twitter
```

- `twitter.card` is a type of a card. We are using "Summary Large Image" which
  features a large, full-width prominent image alongside a tweet. There are several other
  types, like "Player" or "Card", but they are not relevant for a blog. (Required
  field).
- `twitter.title` is an actual title of a blog post or a page. Same as `<title>`.
  Should be approximately 70 characters. (Required field).
- `twitter.description` concise summary of a blog post or a page. Should be approximately
  200 characters. (Non required field).
- `twitter.image` cover image, which is going to be displyed. (Technically non required field).
- `twitter.image:alt` cover image alternative text. Same as image `alt` attribute. Has
  to be no longer that 420 characters. (Non required field, but make sure to fill it in
  if you are using `twitter.image`).
- `twitter.creator` it's you my friend, the person who crafted the content! Make sure
  to use your twitter handle with `@` in the front. (Non required field).

In case you have a separate Twitter account for your blog you might as well
add `twitter:site` with the account handle `@website`.

To validate the markup you can use Twitter's
[card validator tool](https://cards-dev.twitter.com/validator).

## `SchemaOrg` Component

What is Schema.org and JSON-LD?

- schemaId
- address
- person
- organization (why do we have to use it?)
- Page (all different types of pages, how they are simillar and how they are different)
- Breadcrumbs

## Helpful Links

- [Gatsby SEO](https://bloggingfordevs.com/gatsby-seo/)
- [Google Ranking Factors](https://backlinko.com/google-ranking-factors)
- [Search Engine Optimization with Gatsby](https://blog.dustinschau.com/search-engine-optimization-with-gatsby)

## Edits

Create single file component

## Code edits

- Add OG `article:modified_time`
- Remove `og:see_also`

## Order

- Intro
- List of components we are going to build
- Head
  - Title
  - Description
  - HTML
  - Twitter
  - OpenGraph
- SchemaOrg
  - schemaId
  - Address
  - Person
  - Organization
  - Page
  - Breadcrumbs
- Fetching data
  - `useSiteMetadata`
  - GraphQL fragments
- Pages
- Layout
