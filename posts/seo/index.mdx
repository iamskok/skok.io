---
title: Technical Guide to Gatsby's SEO
description: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam eu iaculis elit.
date: 2020-11-12
modifiedDate: 2020-11-14
published: true
cover: ./cover.jpg
coverAlt: SEO image
---

If you are here it means that you care about organic SEO and want more people to
discover your content. This makes total sense, otherwise why even bother
creating content? In this blog post we are going to discuss what we as engineers
can do better in order to make web crawler's life a little easier and hopefully
get rewarded for it. Gatsby and `react-helmet` are going to be our main weapons.

## Prerequisites

I'm making several assumptions in this article:

1. You already have a basic understanding of how Gatsby Node API and GraphQL
   works.
2. The project I'm going to show will have a certain project structure,
   which we will go over shortly. Though don't worry too much about this part,
   because it should be pretty easy to adopt the same principals for a project with
   a different project structure.
3. All blog post examples are written in MDX, so if you are using markdown instead
   you will have to find another way for using `ImageSharp` with image paths taken
   from frontmatter.

And finally if you have any questions feel free to look at the
[final version](https://github.com/iamskok/gatsby-seo)) of the project
or [tweet](https://twitter.com/iamskok) at me with your question.

## Project Structure

The blog we are going to work on has 4 pages - Home, Blog, Contact, and About as well
as 1 template - Article. I prefer to keep the actual content outside of `./src` direcotry
in order to have a clear separation between source code and the actual content. The
content folder can be named as `posts`, `articles`, or `garden` (AKA
[digital garden](https://joelhooks.com/digital-garden)). I'm gonna roll with `posts`.
Every post will be living in it's own folder with an `index.mdx`. All images which will
be used in the post will also be placed in the same `posts` directory. Generic
images are stored in `./src/images`. And that's about it for the project structure,
everything else is pretty standard.

```
├── gatsby-config.js
├── gatsby-node.js
├── site-metadata.js
├── posts
│   ├── article-1
│   │   ├── cover.jpg
│   │   └── index.mdx
│   ├── article-2
│   │   ├── cover.jpg
│   │   └── index.mdx
│   └── article-3
│       ├── cover.jpg
│       └── index.mdx
├── src
│   ├── components
│   ├── images
│   ├── pages
│   │   ├── about.js
│   │   ├── blog.js
│   │   ├── contact.js
│   │   └── index.js
│   └── templates
│       └── article.js
└── static
```

## Site Metadata and `useSiteMetadata` Hook

Before jumping right into the actual coding we have to define define
the data we are going to pass to the SEO components as well as some
mechanism for retrieving the data.

In order to keep `gatsby-config.js` file slim let's create a separate file
which is gonna hold all the static metadata about our blog -
`touch site-metadata.js`.

```js
module.exports = {
  firstName: `Jane`,
  lastName: `Doe`,
  siteUrl: `https://gatsby-seo.netlify.app`,
  logo: {
    url: `logo.jpg`,
    width: 640,
    height: 640,
  },
  language: `en_US`,
  socialMedia: {
    twitter: `https://twitter.com/gatsbyjs`,
    github: `https://github.com/gatsbyjs`,
  },
  address: {
    addressCountry: `US`,
    addressLocality: `Los Angeles`,
    addressRegion: `GA`,
  },
  speakableSelector: [`[data-speakable="true"]`],
  pages: {
    home: {
      to: `/`,
      breadcrumb: `Home`,
      title: `Jane Doe`,
      description: `Jane Doe's personal blog`,
      coverAlt: `Two corgis sitting next to each other`,
      type: `WebPage`,
    },
    blog: {
      to: `/blog/`,
      breadcrumb: `Blog`,
      title: `Blog`,
      description: `Thoughts on software engineering`,
      coverAlt: `Brown retriever is licking it's nose`,
      type: `Blog`,
    },
    contact: {
      to: `/contact/`,
      breadcrumb: `Contact`,
      title: `Contact Jane Doe`,
      description: `Jane Doe's contact information`,
      coverAlt: `Bulldog is chilling on the groud`,
      type: `ContactPage`,
    },
    about: {
      to: `/about/`,
      breadcrumb: `About`,
      title: `About Jane Doe`,
      description: `Jane Doe's biography`,
      coverAlt: `French bulldog is hanging out on the playgroud`,
      type: `AboutPage`,
    },
    article: {
      type: `Article`,
    },
  },
}
```

- `speakableSelector` this is a selector which will tell search engines and some other assistive
  technologies that a particular section on the page is "speakable".
- `to` is a URL pathname.
- `breadcrumb` is a breadcrumb title
- `coverAlt` is the same as image `alt` attribute, but for your cover images.
- `lang` the language of your content. Consists of [language code](https://www.w3schools.com/tags/ref_language_codes.asp)
  and an options [country code](https://www.w3schools.com/tags/ref_country_codes.asp)

Everything else should be pretty self-explanatory. Replace all the values
with your own information, but keep page's `type` as is.

Our next step is to import this file in `gatsby-config.js` so all this information will
become accessible to the GraphQL layer.

```js
const siteMetadata = require("./site-metadata")

module.exports = {
  siteMetadata,
  // ...
}
```

Once we placed the data in the right place we need some way to retrieve it from
react components using GraphQL queries. `useStaticQuery` is exactly what we are
looking. Create `hooks` directory in `./src` - `touch src/hooks/useSiteMetadata.js`

```js
import { useStaticQuery, graphql } from "gatsby"

export default () => {
  const {
    site: { siteMetadata },
  } = useStaticQuery(
    graphql`
      query {
        site {
          siteMetadata {
            firstName
            lastName
            siteUrl
            logo {
              url
              width
              height
            }
            language
            socialMedia {
              twitter
              github
            }
            address {
              addressCountry
              addressLocality
              addressRegion
            }
            speakableSelector
            pages {
              home {
                to
                breadcrumb
                title
                description
                coverAlt
                type
              }
              blog {
                to
                breadcrumb
                title
                description
                coverAlt
                type
              }
              contact {
                to
                breadcrumb
                title
                description
                coverAlt
                type
              }
              about {
                to
                breadcrumb
                title
                description
                coverAlt
                type
              }
              article {
                type
              }
            }
          }
        }
      }
    `
  )

  return siteMetadata
}
```

We are listing every property from `./site-metadata.js` in the graphql query,
destructuring `siteMetadata`, because we are not making any use out of it and now
we are ready to retrieve the data as:

```jsx
import useSiteMetadata from "../../hooks/useSiteMetadata"

const Welcome = () => {
  const { firstName } = useSiteMetadata()

  return <h1>Hello! My name is {firstName}</h1>
}
```

## Basic Data Flow

All the data brewing will start at the page and template level. We are going
to retrieve it using gatsby page queries and `useSiteMetadata` hook.
After this it's going to drain down in the `Layout` component. `Layout` component
will be a place where all the data is aggregated, sorted, and passed deeper
in the actual SEO components.

## Using `useSiteMetadata` Hook To Pull Page Data

Every page has a corresponding data in `./site-metadata.js`, so let's get it in
the page components. Here is the example for the Home page.

```jsx {9,21}
/** @jsx jsx */
import { jsx, Styled } from "theme-ui"
import useSiteMetadata from "../hooks/useSiteMetadata"
import Layout from "../components/Layout"

const Home = () => {
  const {
    pages: {
      home: { to, title, description, coverAlt, type, breadcrumb },
    },
  } = useSiteMetadata()

  return (
    <Layout
      to={to}
      title={title}
      description={description}
      coverAlt={coverAlt}
      breadcrumb={breadcrumb}
      type={type}
      pageName="home"
    >
      {/* ... */}
    </Layout>
  )
}

export default Home
```

There 2 important pieces here:

- page title in `useSitemetaData` destructuring
- `pageName` prop, which corresponds to the component name

They are going to change from page to page. Now add the same
code to the rest of the pages. Feel free to check out the example
[repo](https://github.com/iamskok/gatsby-seo-draft/tree/master/src/pages).

### GraphQL Fragment For Cover Images

Before moving to the Gatsby page queries let's do some preparation. As you
might already know Gatsby has an awesome plugin
[gatsby-transformer-sharp](https://www.gatsbyjs.com/plugins/gatsby-transformer-sharp),
which is used for creating multiple images of the right sizes and resolutions.
It's gonna help us a ton with generating cover images for various aspect ratios.
Why can't we use the same image you might wonder? Well, because all social networks
and search engines (read Google) have different requirments.

- [Facebook](https://developers.facebook.com/docs/sharing/webmasters/images/)
  recommends images to be at least 1200x630 pixels.
- [Twitter](https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/summary-card-with-large-image)
  recommends aspect ratio of 2:1 with minimum dimensions of 300x157 pixels.
- [Google](https://developers.google.com/search/docs/data-types/article) says
  that their images has to be at least 696 pixels wide and suggests
  to provide multiple images with the following aspect ratios: 16x9, 4x3, and 1x1.

Now let's have a look at how this might look in practice for the Home cover image:

```graphql
query {
  file(relativePath: { eq: "home.jpg" }) {
    childImageSharp {
      facebook: fixed(width: 1600, height: 838) {
        src
      }
      twitter: fixed(width: 1600, height: 800) {
        src
      }
      google1x1: fixed(width: 1600, height: 1600) {
        src
      }
      google4x3: fixed(width: 1600, height: 1200) {
        src
      }
      google16x9: fixed(width: 1600, height: 900) {
        src
      }
    }
  }
}
```

Let's break it down. First we are querying for a File in GraphQL
using `gatsby-source-filesystem`. In our case we are targeting a
file by it's relative path, which equals (`eq` operator must match
the given data exactly) to `home.jpg`. It triggers copying of this
file to the public directory.

Important note here is that the relative path is based on the line of
code you put in the `gatsby-source-filesystem` config, in our case it's
`/src/images`

`gatsby-plugin-sharp` powers the connections between Sharp and Gatsby Plugins

In the snippet above we are using Gatsby aliases, because we need to
run multiple queries on the same data source - `childImageSharp`

Example of a fragment.

```GraphQL
query {
  file(relativePath: { eq: "home.jpg" }) {
    childImageSharp {
      ...ChildImageSharpFields
    }
  }
}
```

For each page we need to write a tiny query which will fetch a corresponding cover
image image from GraphQL layer. We are going to do it by targeting a file name.

## Using Gatsby Page Query To Pull Page Data

- gatsby page query
- useSiteMetadata
- Home, Blog, Contact, About, Article pages.

## Helpful Links

- [Gatsby SEO](https://bloggingfordevs.com/gatsby-seo/)
- [Google Ranking Factors](https://backlinko.com/google-ranking-factors)
- [Search Engine Optimization with Gatsby](https://blog.dustinschau.com/search-engine-optimization-with-gatsby)
