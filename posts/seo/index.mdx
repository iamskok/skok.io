---
title: Guide to Gatsby blog SEO
description: Tips and tricks for building powerful SEO components.
date: 2020-11-12
modifiedDate: 2020-11-14
published: true
cover: ./cover.jpg
coverAlt: SEO image
---

**Table of Content**

- Prerequisites
- Project Structure
- Site Metadata and `useSiteMetadata` Hook
- Basic Data Flow
- Using `useSiteMetadata` Hook To Pull Page Data
  - GraphQL Fragment For Cover Images
- Using Gatsby Page Query To Pull Page Data
- `Layout` component
- Head Component
  - HTML Component
  - Title Component
  - Description Component
  - OpenGraph Component
  - Twitter Component
- `SchemaOrg` Component
  - Node identifier utility
  - Address Schema Component
  - Person Schema Component
  - Organization Schema Component
  - Page Schema Component
  - Breadcrumbs Schema Component
- Conclusion
- Helpful Links and Further Reading

import { Message } from "theme-ui"

If you are here it means that you care about organic SEO and want more people to
discover your content. This makes total sense, otherwise why even bother
creating content? In this blog post, we are going to discuss what we as engineers
can do better to make web crawler's life a little easier and hopefully
get rewarded for it. Gatsby and `react-helmet` are going to be our main tools
in this path.

## Prerequisites

I'm making several assumptions in this article:

1. You already have a basic understanding of how Gatsby Node API and GraphQL works.
2. The project I'm going to show will have a certain project structure, which we will
go over shortly. Though don't worry too much about this part, because it should be pretty
easy to adopt the same principles for a project with a different project structure.
3. All blog post examples are written using MDX and Theme-UI, so if you are using markdown
or a different styling solution some things might look slightly different for you.

And finally, if you have any questions feel free to look at the
[final version](https://github.com/iamskok/gatsby-seo) of the project
or [tweet](https://twitter.com/iamskok1) at me with your question.

## Project Structure

The blog we are going to work on has 4 pages - Home, Blog, Contact, About, and an
Article template. I prefer to keep the actual content outside of `./src` directory to
have a clear separation between source code and the actual content. The content folder
can be named as `posts`, `articles`, or `garden` (AKA [digital garden](https://joelhooks.com/digital-garden)).
I'm gonna roll with `posts`. Every post will be living in its own folder with an `index.mdx`.
All images which will be used in the post will also be placed in the same `posts` directory.
Generic images are stored in `./src/images`. And that's about it for the project structure.

```
├── gatsby-config.js
├── gatsby-node.js
├── site-metadata.js
├── posts
│   ├── article-1
│   │   ├── cover.jpg
│   │   └── index.mdx
│   ├── article-2
│   │   ├── cover.jpg
│   │   └── index.mdx
│   └── article-3
│       ├── cover.jpg
│       └── index.mdx
├── src
│   ├── components
│   ├── images
│   ├── pages
│   │   ├── about.js
│   │   ├── blog.js
│   │   ├── contact.js
│   │   └── index.js
│   └── templates
│       └── article.js
└── static
```

## Site Metadata and `useSiteMetadata` Hook

Before jumping right into the actual coding we have to define
the data we are going to pass to the SEO components as well as some
the mechanism for retrieving the data.

To keep `gatsby-config.js` file slim let's create a separate file
which is gonna hold all the static metadata about our blog -
`touch site-metadata.js`.

```js
module.exports = {
  firstName: `Jane`,
  lastName: `Doe`,
  siteUrl: `https://gatsby-seo.netlify.app`,
  logo: {
    url: `logo.jpg`,
    width: 640,
    height: 640,
  },
  language: `en_US`,
  socialMedia: {
    twitter: `https://twitter.com/gatsbyjs`,
    github: `https://github.com/gatsbyjs`,
  },
  address: {
    addressCountry: `US`,
    addressLocality: `Los Angeles`,
    addressRegion: `GA`,
  },
  speakableSelector: [`[data-speakable="true"]`],
  pages: {
    home: {
      to: `/`,
      breadcrumb: `Home`,
      title: `Jane Doe`,
      description: `Jane Doe's personal blog`,
      coverAlt: `Two corgis sitting next to each other`,
      type: `WebPage`,
    },
    blog: {
      to: `/blog/`,
      breadcrumb: `Blog`,
      title: `Blog`,
      description: `Thoughts on software engineering`,
      coverAlt: `Brown retriever is licking it's nose`,
      type: `Blog`,
    },
    contact: {
      to: `/contact/`,
      breadcrumb: `Contact`,
      title: `Contact Jane Doe`,
      description: `Jane Doe's contact information`,
      coverAlt: `Bulldog is chilling on the groud`,
      type: `ContactPage`,
    },
    about: {
      to: `/about/`,
      breadcrumb: `About`,
      title: `About Jane Doe`,
      description: `Jane Doe's biography`,
      coverAlt: `French bulldog is hanging out on the playgroud`,
      type: `AboutPage`,
    },
    article: {
      type: `Article`,
    },
  },
}
```

- `speakableSelector` is a selector which will tell search engines
  and some other assistive technologies that a particular section on
  the page is "speakable".
- `to` is a URL pathname.
- `breadcrumb` is a breadcrumb title
- `coverAlt` is the same as the image `alt` attribute, but for your cover images.
- `lang` the language of your content. Consists of
  [language code](https://www.w3schools.com/tags/ref_language_codes.asp) and an
  options [country code](https://www.w3schools.com/tags/ref_country_codes.asp)

Everything else should be pretty self-explanatory. Now you can go ahead and replace all the
values with your information, but keep the page's `type` field as-is.

Our next step is to import this file in `gatsby-config.js` so all this information will
become accessible to the GraphQL layer.

```js
const siteMetadata = require("./site-metadata")

module.exports = {
  siteMetadata,
  // ...
}
```

Once we placed the data in the right place we need some way to retrieve it from react
components using GraphQL queries. `useStaticQuery` is exactly what we are looking for.
Create `hooks` directory in `./src` - `touch src/hooks/useSiteMetadata.js`

```js
import { useStaticQuery, graphql } from "gatsby"

export default () => {
  const {
    site: { siteMetadata },
  } = useStaticQuery(
    graphql`
      query {
        site {
          siteMetadata {
            firstName
            lastName
            siteUrl
            logo {
              url
              width
              height
            }
            language
            socialMedia {
              twitter
              github
            }
            address {
              addressCountry
              addressLocality
              addressRegion
            }
            speakableSelector
            pages {
              home {
                to
                breadcrumb
                title
                description
                coverAlt
                type
              }
              blog {
                to
                breadcrumb
                title
                description
                coverAlt
                type
              }
              contact {
                to
                breadcrumb
                title
                description
                coverAlt
                type
              }
              about {
                to
                breadcrumb
                title
                description
                coverAlt
                type
              }
              article {
                type
              }
            }
          }
        }
      }
    `
  )

  return siteMetadata
}
```

We are listing every property from `./site-metadata.js` in the graphql query,
destructuring `siteMetadata` and now we are ready to retrieve the data as:

```jsx
import useSiteMetadata from "../../hooks/useSiteMetadata"

const Welcome = () => {
  const { firstName } = useSiteMetadata()

  return <h1>Hello! My name is {firstName}</h1>
}
```

## Basic Data Flow

All the data brewing will start at the page (`./src/pages/about.js`,
`./src/pages/blog.js`, `./src/pages/contact.js`, `./src/pages/index.js`)
and template (`./src/templates/article.js`) level and then will be passed
down to the SEO components. We are going to retrieve it using gatsby page
queries and `useSiteMetadata` hook. After this, it's going to drain down in
the `Layout` component. The `Layout` component will be a place where all the
data is aggregated, sorted, and passed deeper in the actual SEO components.

## Using `useSiteMetadata` Hook To Pull Page Data

Every page has corresponding data in `./site-metadata.js`, so let's get it in
the page components. Here is the example for the Home page.

```jsx {9,21}
/** @jsx jsx */
import { jsx, Styled } from "theme-ui"
import useSiteMetadata from "../hooks/useSiteMetadata"
import Layout from "../components/Layout"

const Home = () => {
  const {
    pages: {
      home: { to, title, description, coverAlt, type, breadcrumb },
    },
  } = useSiteMetadata()

  return (
    <Layout
      to={to}
      title={title}
      description={description}
      coverAlt={coverAlt}
      breadcrumb={breadcrumb}
      type={type}
      pageName="home"
    >
      {/* ... */}
    </Layout>
  )
}

export default Home
```

There 2 important pieces here:

- page title key in pages (`useSiteMetaData` destructuring block)
- `pageName` prop, which corresponds to the component's name

They are going to change from page to page. Now add the same
code to the rest of the pages. Feel free to check out the example
[repo](https://github.com/iamskok/gatsby-seo-draft/tree/master/src/pages).

### GraphQL Fragment For Cover Images

Before moving to the Gatsby page queries let's do some preparation. Gatsby has an awesome
plugin [gatsby-transformer-sharp](https://www.gatsbyjs.com/plugins/gatsby-transformer-sharp),
which is used for creating multiple images of the right sizes and resolutions. It's gonna
help us a ton with generating cover images for various aspect ratios. You might be wondering
why we can't use the same image? Well, because all social networks and search engines have
different requirements.

- [Facebook](https://developers.facebook.com/docs/sharing/webmasters/images/)
  recommends images to be at least 1200x630 pixels.
- [Twitter](https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/summary-card-with-large-image)
  recommends an aspect ratio of 2:1 with minimum dimensions of 300x157 pixels.
- [Google](https://developers.google.com/search/docs/data-types/article) says that their
images have to be at least 696 pixels wide and suggests to provide multiple images with
the following aspect ratios: 16x9, 4x3, and 1x1.

Now let's see how this might look in practice for the Home cover image:

```graphql
query {
  file(relativePath: { eq: "home.jpg" }) {
    childImageSharp {
      facebook: fixed(width: 1600, height: 838) {
        src
      }
      twitter: fixed(width: 1600, height: 800) {
        src
      }
      google1x1: fixed(width: 1600, height: 1600) {
        src
      }
      google4x3: fixed(width: 1600, height: 1200) {
        src
      }
      google16x9: fixed(width: 1600, height: 900) {
        src
      }
    }
  }
}
```

Let's break it down. First, we are querying for a File in GraphQL
using `gatsby-source-filesystem`. In our case, we are targeting a
file by its relative path, which equals (`eq` operator must match
the given data exactly) to `home.jpg`. It triggers copying of this
file to the `public` directory.

<Message variant="primary">
  The relative path is based on the line of code you put in the
  `gatsby-source-filesystem` in `gatsby-config.js`, in our case it's
  `/src/images`.
</Message>

On line `4-16` we are using Gatsby aliases (`facebook`, `twitter`,
`google1x1`, `google4x3`, `google16x9`), because we need to
run multiple queries with different arguments on the same data
source - `childImageSharp`.

This query will be required for every page (home, contact, blog, about)
and repeating it violates the [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)
principle. The only piece, which will be different is the image title.
GraphQL fragments will come to the rescue. Fragments are reusable units,
they let you construct sets of fields, and then include them in queries
where you need to.

Let's create our fragment `touch src/fragments/ImageSharpFields.js`.

```js
import { graphql } from "gatsby"

export const ChildImageSharpFields = graphql`
  fragment ChildImageSharpFields on ImageSharp {
    google1x1: fixed(width: 1600, height: 1600) {
      src
    }
    google4x3: fixed(width: 1600, height: 1200) {
      src
    }
    google16x9: fixed(width: 1600, height: 900) {
      src
    }
    twitter: fixed(width: 1600, height: 800) {
      src
    }
    facebook: fixed(width: 1600, height: 838) {
      src
    }
  }
`
```

We are defining the fragment name `ChildImageSharpFields` that will be referenced in other
queries. Specifying the type name `ImageSharp` of an object the fragment will be used on.
Then we move aliases from the initial example in the query body. And to make this fragment is
accessible inside of the other GraphQL queries we use named export (There is no need to import
this fragment, Gatsby automatically makes it globally available).

And here is how you can use this fragment.

```graphql
query {
  file(relativePath: { eq: "home.jpg" }) {
    childImageSharp {
      ...ChildImageSharpFields
    }
  }
}
```

This looks way better, right?

## Using Gatsby Page Query To Pull Page Data

At this point, we have `useSiteMetadata` hook and fragments in place, so we can finish
pulling all the data we need in all the pages and template.

```jsx {7,13,20,31-39}
/** @jsx jsx */
import { jsx, Styled } from "theme-ui"
import { graphql } from "gatsby"
import useSiteMetadata from "../hooks/useSiteMetadata"
import Layout from "../components/Layout"

const Home = ({ data }) => {
  const {
    pages: {
      home: { to, title, description, coverAlt, type, breadcrumb },
    },
  } = useSiteMetadata()
  const covers = data?.file?.childImageSharp

  return (
    <Layout
      to={to}
      title={title}
      description={description}
      covers={{ ...covers }}
      coverAlt={coverAlt}
      breadcrumb={breadcrumb}
      type={type}
      pageName="home"
    >
      {/* ... */}
    </Layout>
  )
}

export const query = graphql`
  query {
    file(relativePath: { eq: "home.jpg" }) {
      childImageSharp {
        ...ChildImageSharpFields
      }
    }
  }
`

export default Home
```

On line `31-39` we define the query for the cover image and the data coming from this
query becomes accessible via the `data` prop in the `Home` component. Let's grab the
part we are interested in - `covers` and spread it in the `covers` prop of the `Layout`
component.

Here is the example of the `Article` template.

```jsx
/** @jsx jsx */
import { jsx, Styled, Flex } from "theme-ui"
import { graphql } from "gatsby"
import { MDXRenderer } from "gatsby-plugin-mdx"
import Img from "gatsby-image"
import useSiteMetadata from "../hooks/useSiteMetadata"
import Layout from "../components/Layout"

const Article = ({ data, pageContext }) => {
  const {
    mdx: {
      body,
      frontmatter: { title, description, date, modifiedDate, cover, coverAlt },
    },
  } = data
  const { slug } = pageContext
  const {
    pages: {
      article: { type, breadcrumb },
    },
  } = useSiteMetadata()

  const childImageSharp = cover?.childImageSharp

  return (
    <Layout
      type={type}
      slug={slug}
      title={title}
      date={date}
      modifiedDate={modifiedDate}
      covers={{ ...childImageSharp }}
      coverAlt={coverAlt}
      description={description}
      breadcrumb={breadcrumb}
      pageName="article"
    >
      {/* ... */}
    </Layout>
  )
}

export default Article

export const query = graphql`
  query($id: String!) {
    mdx(id: { eq: $id }) {
      id
      body
      frontmatter {
        title
        description
        date(formatString: "MMMM DD, YYYY")
        modifiedDate(formatString: "MMMM DD, YYYY")
        coverAlt
        cover {
          childImageSharp {
            ...ChildImageSharpFields
          }
        }
      }
    }
  }
`
```

In `Article` template we are taking `slug` from `pageContext`, using
`useSiteMetadata` to query `type` and `breadcrumb` and the rest of the
data comes from the page query, specifically from the `frontmatter`
fields on `mdx`.

If you are not familiar with `pageContext` have a look at the
[Gatsby Docs](https://www.gatsbyjs.com/docs/creating-and-modifying-pages/#pass-context-to-pages) or
check out the [`gatsby-config.js`](https://github.com/iamskok/gatsby-seo-draft/blob/master/gatsby-node.js)
from the example repo.

## `Layout` component

`Layout` is the most data-heavy component. It receives multiple props from the data passed to it
from pages and templates and fetches the remaining static data using the `useSiteMetadata` hook. Let's
create one `touch src/components/Layout/index.js`.

```jsx {35-41,43-60}
/** @jsx jsx */
import { Fragment } from "react"
import { jsx } from "theme-ui"
import useSiteMetadata from "../../hooks/useSiteMetadata"
import Head from "../Head"
import SchemaOrg from "../SchemaOrg"

const Layout = ({
  children,
  to,
  slug,
  title,
  description,
  cover,
  covers,
  coverAlt,
  pageName,
  type,
  breadcrumb,
  date,
  modifiedDate,
}) => {
  const {
    siteUrl,
    firstName,
    lastName,
    socialMedia,
    pages,
    logo,
    language,
    address,
    speakableSelector,
  } = useSiteMetadata()

  const isPage = {
    article: pageName === `article`,
    home: pageName === `home`,
    blog: pageName === `blog`,
    about: pageName === `about`,
    contact: pageName === `contact`,
  }

  const page = {
    url: isPage.home
      ? siteUrl
      : isPage.article
      ? `${siteUrl}${slug}`
      : `${siteUrl}${to}`,
    speakableSelector: !isPage.blog && speakableSelector,
    covers: (() => {
      const coverURLs = {}
      for (const [key, { src }] of Object.entries(covers)) {
        coverURLs[key] = `${siteUrl}${src}`
      }
      return coverURLs
    })(),
  }

  return (
    <Fragment>
      <Head
        url={page.url}
        title={title}
        description={description}
        covers={page.covers}
        coverAlt={coverAlt}
        firstName={firstName}
        lastName={lastName}
        socialMedia={socialMedia}
        date={date}
        language={language}
        pages={pages}
        isPage={isPage}
      />
      {/* ... */}
      <SchemaOrg
        to={to}
        slug={slug}
        url={page.url}
        siteUrl={siteUrl}
        title={title}
        description={description}
        covers={page.covers}
        firstName={firstName}
        lastName={lastName}
        socialMedia={socialMedia}
        type={type}
        breadcrumb={breadcrumb}
        date={date}
        modifiedDate={modifiedDate}
        address={address}
        language={language}
        logo={logo}
        pages={pages}
        isPage={isPage}
        speakableSelector={page.speakableSelector}
      />
    </Fragment>
  )
}

export default Layout
```

On line `35-41` we create `isPage` object which acts as helpers in the data filtering process.
This object is going to be passed as a prop down in `Head` and `SchemaOrg` components.

Line `43-60` defines the `page` object which composes the proper data, which is going to be
passed down the tree. `url` property constructs page URL for a current page.

- Home - `/`
- Blog - `/blog/`
- Contact - `/contact/`
- About - `/about/`
- Article - `/blog/article-title/`

`speakableSelector` is used on all of the templates except blog and this is what
we check with `!isPage.blog` (we are going to talk about in more details in
Page Schema Component section).

`covers` takes care of transforming cover images object. GraphQL returns `covers` object which looks, like:

```json
{
  "google1x1": {
    "src": "/static/402ec135e08c3b799c16c08a82ae2dd8/acd4e/home.jpg"
  },
  "google4x3": {
    "src": "/static/402ec135e08c3b799c16c08a82ae2dd8/feead/home.jpg"
  },
  "google16x9": {
    "src": "/static/402ec135e08c3b799c16c08a82ae2dd8/fb8ef/home.jpg"
  },
  "twitter": {
    "src": "/static/402ec135e08c3b799c16c08a82ae2dd8/70d01/home.jpg"
  },
  "facebook": {
    "src": "/static/402ec135e08c3b799c16c08a82ae2dd8/10355/home.jpg"
  }
}
```

`covers` is being used in multiple places, so it's going to be much nicer
if the object will take in this form:

```
{
  "google1x1": "/static/402ec135e08c3b799c16c08a82ae2dd8/acd4e/home.jpg",
  "google4x3": "/static/402ec135e08c3b799c16c08a82ae2dd8/feead/home.jpg",
  "google16x9": "/static/402ec135e08c3b799c16c08a82ae2dd8/fb8ef/home.jpg",
  "twitter": "/static/402ec135e08c3b799c16c08a82ae2dd8/70d01/home.jpg",
  "facebook": "/static/402ec135e08c3b799c16c08a82ae2dd8/10355/home.jpg",
}
```

## Head Component

`Head` component will consist of several other components because I
personally prefer breaking large components into smaller pieces.

```jsx
import React from "react"
import Html from "./Html"
import Title from "./Title"
import Description from "./Description"
import OpenGraph from "./OpenGraph"
import Twitter from "./Twitter"

const Head = ({
  url,
  title,
  description,
  covers: { twitter: twitterCover, facebook: facebookCover },
  coverAlt,
  socialMedia,
  date,
  language,
  firstName,
  lastName,
  pages: {
    home: { title: siteName },
  },
  isPage,
}) => {
  const { twitter: twitterHandle } = socialMedia

  return (
    <>
      <Html language={language} />
      <Title title={title} />
      <Description description={description} />
      <OpenGraph
        url={url}
        title={title}
        description={description}
        image={facebookCover}
        imageAlt={coverAlt}
        publishedTime={date}
        siteName={siteName}
        firstName={firstName}
        lastName={lastName}
        locale={language}
        seeAlso={socialMedia}
        isArticle={isPage.article}
      />
      <Twitter
        title={title}
        description={description}
        image={twitterCover}
        imageAlt={coverAlt}
        creator={twitterHandle}
      />
    </>
  )
}

export default Head
```

Nothing fancy is going on here we are just receiving data from `Layout`
component and passing it further down.

### HTML Component

In HTML, the language declaration is an attribute that states the language
of the page’s content and optionally its geographic location.

```jsx
import React from "react"
import { Helmet } from "react-helmet"

const Html = ({ language }) => (
  <Helmet>
    <html lang={language} />
  </Helmet>
)

export default Html
```

We are wrapping the `html` tag in the `Helmet` component, which takes care of rendering its
content inside of the `head` tag of the HTML document.

> This reusable React component will manage all of your changes to the
> document head. Helmet takes plain HTML tags and outputs plain HTML tags.
> It's dead simple, and React beginner-friendly.
>
> [`react-helmet` GitHub page](https://github.com/nfl/react-helmet)

### Title Component

An almost identical thing happens in the `Title` component, but this
time we are wrapping `title` tag in `Helmet`.

```jsx
import React from "react"
import { Helmet } from "react-helmet"

const Title = ({ title }) => {
  return (
    <Helmet>
      <title>{title}</title>
    </Helmet>
  )
}

export default Title
```

### Description Component

```jsx
import React from "react"
import { Helmet } from "react-helmet"

const Description = ({ description }) => (
  <Helmet>
    <meta name="description" content={description} />
  </Helmet>
)

export default Description
```

### OpenGraph Component

The Open Graph protocol is supported by a wide range of social platforms which
includes Facebook (it also created this protocol in 2010), LinkedIn, Pinterest,
Twitter, and others. To learn more about it you can have a look at
[Open Graph protocol documention](https://ogp.me/)

Open Graph component is going to render data conditionally based on the page type.
This is when `isPage` object, which is being passed down from the `Layout` component becomes handy.

```jsx
import React from "react"
import { Helmet } from "react-helmet"

const OpenGraph = ({
  url,
  title,
  description,
  image,
  imageAlt,
  publishedTime,
  siteName,
  firstName,
  lastName,
  locale,
  seeAlso,
  isArticle,
}) => (
  <Helmet>
    <meta property="og:url" content={url} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content={image} />
    <meta property="og:image:alt" content={imageAlt} />
    <meta property="og:site_name" content={siteName} />
    {!isArticle && <meta property="profile:first_name" content={firstName} />}
    {!isArticle && <meta property="profile:last_name" content={lastName} />}
    <meta property="og:locale" content={locale} />
    <meta property="og:type" content={isArticle ? `article` : `website`} />
    {isArticle && (
      <meta property="article:published_time" content={publishedTime} />
    )}
    {isArticle && modifiedTime && (
      <meta property="article:modified_time" content={modifiedTime} />
    )}
    {isArticle && (
      <meta property="article:author" content={`${firstName} ${lastName}`} />
    )}
  </Helmet>
)

export default OpenGraph
```

- `og:type` the type of your object, which is represented in Open Graph. It can be music, video,
website, profile, article, and several others. In our blog, we will be using `article` if it's an
article template or `website` for the rest of the pages. (Required field).
- `og:title` blog post or a page title. (Required field).
- `og:description` a one to two sentence description of the page content.
- `og:url` the canonical URL of the object. Make sure to pay close attention to
  `www` subdomain and trailing `/`. (Required field).
- `og:image` cover image. (Required field).
- `og:image:alt` cover image description. (Technically not required, but I urge you to use it).
- `og:site_name` your blog name.
- `og:locale` the language of the content. It defaults to `en_US`.
- `article:author` author of the article if `og:type` is `article`.
- `article:published_time` publish time of the article if `og:type` is `article`.
- `article:modified_time` - modified time of the article if `og:type` is `article`.
- `profile:first_name` your first name if `og:type` is `website`.
- `profile:last_name` your last name if `og:type` is `website`.

To debug Open Graph markup you can use [Facebook Debug Tool](https://developers.facebook.com/tools/debug),
but unfortunately it requires a Facebook developer's account.

### Twitter Component

Twitter markup has some intersections with Open Graph.
In certain cases when Twitter can't find twitter meta tags it will
fall back into using Open Graph meta tags. You can read more about it
in [Twitter docs](https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/markup)

```jsx
import React from "react"
import { Helmet } from "react-helmet"

const Twitter = ({ title, description, image, imageAlt, creator }) => (
  <Helmet>
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:title" content={title} />
    <meta property="twitter:description" content={description} />
    <meta property="twitter:image" content={image} />
    <meta property="twitter:image:alt" content={imageAlt} />
    <meta name="twitter:creator" content={creator} />
  </Helmet>
)

export default Twitter
```

- `twitter.card` is a type of card. We are using "Summary Large Image" which features a large,
full-width prominent image alongside a tweet. There are several other types, like "Player" or "Card",
but we are not going to use them. (Required field).
- `twitter.title` is an actual title of a blog post or a page. Same as `<title>`.
  Should be approximately 70 characters. (Required field).
- `twitter.description` concise summary of a blog post or a page. Should be approximately 200
characters. (Non-required field).
- `twitter.image` cover image, which is going to be displayed. (Technically not required field).
- `twitter.image:alt` cover image alternative text. Same as image `alt` attribute. Has to be no
longer than 420 characters. (Non-required field, but make sure to fill it in if you are using
`twitter.image`).
- `twitter.creator` it's you my friend, the person who crafted the content! Make sure to use
your Twitter handle with `@` in the front. (Non-required field).

In case you have a separate Twitter account for your blog you might as well add `twitter:site`
with the account handle `@website`.

To validate the markup you can use Twitter's [card validator tool](https://cards-dev.twitter.com/validator).

## `SchemaOrg` Component

What are Schema.org and JSON-LD?

Schema.org is a structured data markup, which helps search engines interpret the content of web pages.
It was initially launched in 2011 by Google, Yahoo, and Bing. Once added to a webpage it conveys the
contextual meaning to search engines by using a hierarchical set of schemas.

![Schema.org Graph](https://upload.wikimedia.org/wikipedia/commons/8/8e/Schema.org_%285925660995%29.png)

HTML cannot provide a meaning of what a text string means. E.g. a webpage can have a header of
`<h1>Apple</h1>` and it can refer to a fruit or a company. This is when schema.org comes into play
and provides semantical meaning to search engines.

There are several different formats in which you can represent schema.org, but the most popular one
is [JSON-LD](https://json-ld.org/). By far this is the most intuitive for all developers, because
it's almost identical to a well know JSON format. Its implementation doesn't depend on the markup as
opposed to other schema.org formats which attach special attributes to HTML elements and are more
prone to errors.

[What is JSON-LD](https://www.youtube.com/watch?v=4x_xzT5eF5Q)

[Schema.org vocabulary](https://schema.org/docs/full.html) is extremely broad and in
order to be practical we are going to focus on the schemas, which are
[officially supported by Google](https://developers.google.com/search/docs/guides/search-gallery).
This way we are going to help search engines as well as benefit from rich snippets. Rich snippets
stand out from the other search results, look more appealing, and have a higher click-thru rate.

Before jumping into coding I want to make you familiar with the concept of node identifiers. To put
it in simple words it's a unique `@id` property, which gets attached to a schema and then can be
referenced inside of another schema. This is extremely useful for keeping your code DRY and readable.

Take a look at this example:

```html
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "PostalAddress",
    "@id": "https://gatsby-seo.netlify.app/#address",
    "addressCountry": "US",
    "addressLocality": "Los Angeles",
    "addressRegion": "CA"
  }
</script>
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Person",
    "@id": "https://example.com/#person",
    "name": "Jane Doe",
    "address": { "@id": "https://example.com/#address" }
  }
</script>
```

We defined postal address schema and then we are referencing it inside
of the person schema. Keep in mind that this is a simplified example and
real-world schemas can get pretty bulky.

### Node identifier utility

Node identifier value can be pretty much anything, but the convention is to use the domain
name and hash `https://example.com/#your-schema`. Let's create a tiny helper function which
we will be used later on.

```js
import { siteUrl } from "../../../site-metadata"

const schemaId = hash => `${siteUrl}/#${hash}`

export default schemaId
```

We are directly importing an object from `site-metadata.js` because
we can't use hooks outside of React components. We will be able to call this function like,
so: `schemaId("address")` and it will return `https://example.com/#address`.

### Address Schema Component

Let's start building out smaller schemas which will be referenced in the larger
ones.

```jsx
import React from "react"
import schemaId from "./schemaId"

const Address = ({
  address: { addressCountry, addressLocality, addressRegion },
}) => {
  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{
        __html: JSON.stringify({
          "@context": `https://schema.org`,
          "@type": `PostalAddress`,
          "@id": schemaId(`address`),
          addressCountry,
          addressLocality,
          addressRegion,
        }),
      }}
    />
  )
}

export default Address
```

In the code above we are adding a postal address with 3 properties - `country`, `locality`,
and `region`. There are many other properties, so make sure to check out the official
[`PostalAddress` page](https://schema.org/PostalAddress) and add them to your own needs
(this also applies to the rest of the schemas).

In order to inject JSON object in the `script` tag we are using a combination of `dangerouslySetInnerHTML`
and `JSON.stringify`.

### Person Schema Component

```jsx
import React from "react"
import schemaId from "./schemaId"

const Person = ({ name, url, sameAs }) => {
  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{
        __html: JSON.stringify({
          "@context": `https://schema.org`,
          "@type": `Person`,
          "@id": schemaId(`person`),
          name,
          url,
          sameAs: Object.values(sameAs),
          address: {
            "@id": schemaId(`address`),
          },
        }),
      }}
    />
  )
}

export default Person
```

For the person schema we are adding our `name`, blog `url`, `sameAs` - which is a list of our
social media profiles, and `address` by referencing previously defined `Address` schema.

### Organization Schema Component

The next one in our list is the `Organization` schema. You might think why would we need it if
we are adding markup for a personal blog. Well, it's going to be required later on when we will
be adding the `Article` schema. Even though [schema.org](https://schema.org/Article) tells us
that `publisher` property (which is a required field for the article schema) can be either
organization or a person in practice Google's structured data validator tool will throw an error.

```jsx
import React from "react"
import schemaId from "./schemaId"

const Organization = ({
  url,
  name,
  logo: { url: logoPathName, width, height },
}) => {
  const logoUrl = `${url}/${logoPathName}`

  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{
        __html: JSON.stringify({
          "@context": `http://schema.org`,
          "@id": schemaId(`organization`),
          "@type": `Organization`,
          url,
          name,
          logo: {
            "@type": `ImageObject`,
            url: logoUrl,
            height,
            width,
          },
          address: {
            "@id": schemaId(`address`),
          },
        }),
      }}
    />
  )
}

export default Organization
```

It's sufficient to add `logo` and `name`, but because we already have `url`, `name`, and `address` we
will add them as well.

### Page Schema Component

Once we are done with smaller pieces we can start working on the bigger schemas.
We will create a reusable Page component and handle `WebPage`, `Blog`, `ContactPage`, `AboutPage`,
and `Article` altogether because they are very similar. Let's write down the part, which will be
identical for all of the pages:

```jsx
import React from "react"
import schemaId from "./schemaId"

const Page = ({
  type,
  headline,
  description,
  dateModified,
  datePublished,
  mainEntityOfPage,
  url,
  name,
  inLanguage,
  images,
  cssSelector,
}) => {
  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{
        __html: JSON.stringify({
          "@context": `http://schema.org`,
          "@type": type,
          author: {
            "@id": schemaId(`person`),
          },
          publisher: {
            "@id": schemaId(`organization`),
          },
          description,
          headline,
          inLanguage,
          name,
          url,
          mainEntityOfPage: {
            "@type": `WebPage`,
            "@id": mainEntityOfPage,
          },
          image: [images?.google1x1, images?.google4x3, images?.google16x9],
        }),
      }}
    />
  )
}

export default Page
```

- `type`- schema type
- `name` - the name of the page.
- `description` - description of the page.
- `author` - author of the content.
- `publisher` - content publisher. We are using node reference by passing the id of the organization
schema (As you might remember we specifically defined it to satisfy Google's structured data validator).
- `headline` - page headline.
- `inLanguage` - the language of the content.
- `url` - URL of the page.
- `mainEntityOfPage` - indicates a page for which this thing is the main entity being described. In the
case of the blog, the primary topic is clear, so we are going to use the same value as `url`. (For more
complicated websites this might not be the case).
- `image` - list of images with 1x1, 4x3, and 16x9 aspect ratios.

There are also properties, which we will be added conditionally depending on the page type. For the
`Article` page it will be `datePublished`, and `dateModified`. And the `Blog` page can't
have `speakable` property.

`speakable` indicate sections of a Web page that are particularly 'speakable' in the sense of being
highlighted as being especially appropriate for text-to-speech conversion.
[Google](https://developers.google.com/search/docs/data-types/speakable) recently started using
speakable structured data to answer topical news queries on smart speaker devices.

```jsx {5,11-22}
<script
  type="application/ld+json"
  dangerouslySetInnerHTML={{
    __html: JSON.stringify(
      Object.assign(
        {
          "@context": `http://schema.org`,
          "@type": type,
          // static properties of the schema ...
        },
        datePublished && { datePublished },
        dateModified
          ? { dateModified }
          : datePublished
          ? { dateModified: datePublished }
          : null,
        cssSelector && {
          speakable: {
            "@type": `SpeakableSpecification`,
            cssSelector,
          },
        }
      )
    ),
  }}
/>
```

To conditionally add properties to the object we are leveraging
`Object.assign(target, ...sources)`. All static properties are our `target`
and all optional properties are our `source`. If you want to dig into this
syntax a little further I recommend checking out this
[StackOverflow link](https://stackoverflow.com/questions/11704267/in-javascript-how-to-conditionally-add-a-member-to-an-object).
`dateModified` needs an extra bit of logic. In order not to define
`dateModified` in the frontmatter for every new blog post we check if
it exists and then we apply it, otherwise, we are reusing `datePublished`
value (we are doing it because `dateModified` is the required property
on the `Article` schema).

### Breadcrumbs Schema Component

`BreadcrumbList` is independent and doesn't appear to be a part of any
other schema. It consists of a chain of linked web pages. The position
property is used to order the items and starts with `1` (and not with
`0` as you devs might think 😂). The first item is the root of the website.

```jsx {15-40}
import React from "react"
import schemaId from "./schemaId"

const Breadcrumbs = ({
  siteUrl,
  title,
  homeBreadcrumb,
  blogBreadcrumb,
  isPage,
  blogTo,
  slug,
  to,
  breadcrumb,
}) => {
  const itemListElement = [
    {
      id: siteUrl,
      name: `${homeBreadcrumb}`,
    },
  ]

  if (isPage.blog || isPage.contact || isPage.about) {
    itemListElement.push({
      id: `${siteUrl}${to}`,
      name: breadcrumb,
    })
  }

  if (isPage.article) {
    itemListElement.push(
      {
        id: `${siteUrl}${blogTo}`,
        name: blogBreadcrumb,
      },
      {
        id: `${siteUrl}${blogTo}${slug}`,
        name: title,
      }
    )
  }

  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{
        __html: JSON.stringify({
          "@context": `http://schema.org`,
          "@type": `BreadcrumbList`,
          "@id": schemaId(`breadcrumbs`),
          name: `Breadcrumbs`,
          itemListElement: itemListElement.map(({ id, name }, index) => ({
            "@type": `ListItem`,
            position: index + 1,
            name,
            item: {
              "@type": `WebPage`,
              "@id": id,
            },
          })),
        }),
      }}
    />
  )
}

export default Breadcrumbs
```

On lines 15-40, we construct an array of links depending on the page.
The very first item is always going to be the homepage, that the reason
why we define `itemListElement` with `siteUrl` right away. The second
level is a blog, contact, or about page. The third level is an article and we
know that it always goes after the blog page, that's why we push both of the
values to the `itemListElement` array at the same time.

## Conclusion

Crafting `Head` and `SchemaOrg` components will help you improve your organic SEO as well
as social media sharing, but do remember that this is not a silver bullet. Think about it as
a complementary thing for the great content you are going to be producing.

## Helpful Links and Further Reading

- [Gatsby SEO](https://bloggingfordevs.com/gatsby-seo/)
- [Google Ranking Factors](https://backlinko.com/google-ranking-factors)
- [Annotated JSON-LD structured data examples](https://nystudio107.com/blog/annotated-json-ld-structured-data-examples)
- [Structured Data JSON-LD examples](https://github.com/JayHoltslander/Structured-Data-JSON-LD)
- [Google's officially supported structured data types](https://developers.google.com/search/docs/data-types/article)
- [Open Graph Protocol Examples](https://github.com/niallkennedy/open-graph-protocol-examples)
